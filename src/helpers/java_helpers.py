import subprocess
from subprocess import run
import csv
import re

def compile_java_class(file_path: str) -> None:
    """Compile Java source file at `file_path` and generate `.class` file"""
    compilation_process = subprocess.run(['javac', file_path])

def get_trace_xml(jbmc_path: str, class_name: str, method_name: str, options=None) -> str:
    """
    Run JBMC tool to generate XML trace for the given Java class and method.

    Args:
        jbmc_path (str): Path to the JBMC executable.
        class_name (str): Name of the Java class.
        method_name (str): Name of the method.
        options (list, optional): Additional options for JBMC.

    Returns:
        str: XML trace generated by JBMC.
    """
    assert options is None or len(options) > 0

    command = [jbmc_path, f'{class_name}.{method_name}', '--xml-ui']
    if options is not None:
        command.extend(options)

    result = run(command, capture_output=True, text=True)
    return result.stdout

def get_all_method_names(java_file_path: str) -> list:
    """
    Extracts all method names found in the Java file.

    Args:
        java_file_path (str): Path to the Java source file.

    Returns:
        list: List of method names.
    """
    method_names = []
    with open(java_file_path, 'r') as file:
        content = file.read()
        # Regular expression to match method signatures
        method_pattern = re.compile(r'\b(?:public|private|protected|static|\s) +[\w\<\>\[\]]+\s+(\w+)\s*\([^)]*\)\s*{')
        matches = method_pattern.findall(content)
        method_names.extend(matches)
    return method_names

def generate_java_source(test_class_name: str, out_class_name: str, counterexample_inputs, reason: str, method_name: str) -> str:
    """
    Generate Java source code from counterexample inputs.

    Args:
        test_class_name (str): Name of the test class.
        out_class_name (str): Name of the output class.
        counterexample_inputs (dict): Counterexample inputs.
        reason (str): Reason for the counterexample.
        method_name (str): Name of the method associated with the counterexample.

    Returns:
        str: Generated Java source code.
    """
    source_code = []

    # Add a comment indicating the reason for the counterexample
    source_code.append(f'// Counterexample for: {reason}')

    # Begin generating the Java class
    source_code.append(f'class {out_class_name} {{')
    source_code.append('\tpublic static void main(String[] args) {')

    # Initialize variable names and index
    var_name_base = "classVar"
    var_index = 0

    # Iterate through counterexample inputs
    for var_name, var_info in counterexample_inputs.items():
        var_type = var_info['type']
        var_value = var_info['value']

        # Handle object and array initialization
        if isinstance(var_value, dict):
            source_code.extend(generate_object_initialization(var_name, var_value, indent=2))
        elif isinstance(var_value, list):
            source_code.extend(generate_array_initialization(var_name, var_value, indent=2))
        else:
            # Construct assignment expression
            assignment_expr = f"{var_type} {var_name} = {var_value}"
            source_code.append(f"\t\t{assignment_expr};")

    # Generate argument list for the test method call
    arg_list = ", ".join(counterexample_inputs.keys())
    source_code.append(f'\t\t{test_class_name}.{method_name}({arg_list});')

    # Close main method and class
    source_code.append('\t}')
    source_code.append('}')

    return '\n'.join(source_code)

def generate_object_initialization(var_name, obj_value: dict, indent=0) -> list:
    """
    Generate object initialization code recursively.

    Args:
        var_name (str): Name of the variable.
        obj_value (dict): Object value.
        indent (int, optional): Indentation level.

    Returns:
        list: List of lines of code for object initialization.
    """
    source = []
    indent_str = "\t" * indent

    # Initialize object
    source.append(f'{indent_str}{obj_value["__class"]} {var_name} = new {obj_value["__class"]}();')

    # Populate object properties
    for prop_name, prop_value in obj_value.items():
        if prop_name == '__class':
            continue

        if isinstance(prop_value, str):
            source.append(f'{indent_str}{var_name}.{prop_name} = {prop_value};')
        elif isinstance(prop_value, dict):
            sub_obj_code = generate_object_initialization(f'{prop_name}_{var_name}', prop_value, indent)
            source.extend(sub_obj_code)
            source.append(f'{indent_str}{var_name}.{prop_name} = {prop_name}_{var_name};')

    return source

def generate_array_initialization(var_name, array_value: list, indent=0) -> list:
    """
    Generate array initialization code.

    Args:
        var_name (str): Name of the variable.
        array_value (list): Array value.
        indent (int, optional): Indentation level.

    Returns:
        list: List of lines of code for array initialization.
    """
    source = []
    indent_str = "\t" * indent

    array_type, elements = array_value
    source.append(f'{indent_str}{array_type}[] {var_name} = new {array_type}[{len(elements)}];')

    for i, element in enumerate(elements):
        if isinstance(element, dict):
            sub_obj_code = generate_object_initialization(f'{var_name}[{i}]', element, indent)
            source.extend(sub_obj_code)
        else:
            source.append(f'{indent_str}{var_name}[{i}] = {element};')

    return source
